---
layout: post
title: 《Designing Data-Intensive Application》读书笔记
categories: Distributed system
description: 《Designing Data-Intensive Application》读书笔记
keywords: Data-Intensive
excerpt: Data-Intensive Application
---

# 数据系统的基石
## 可靠性，可扩展性，可维护性
### 可靠性
fault和failure不同，fault意思是系统的一部分状态偏离其标准，而failure则是系统作为一个整体停止向用户提供服务。fault的概率不可能降到零，因此需要一定的容错机制来防止fault导致failure

有时在一些容错系统中需要通过故意触发来提高故障率，来确保容错机制不断运行并接受考验，从而提高故障自然发生时系统能正确处理的信心

分布式系统的故障大致可分为：硬件故障、软件错误和人为错误（如配置错误）

### 可扩展性
这一部分需要关注负载参数和性能指标

负载参数可以是是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率等

对于在线系统，通常考虑的性能指标是response time，即客户端发送请求到接收响应之间的时间。需要注意的是response time不同于latency（包含了latency）

Tail latencies（high latencies that clients see fairly infrequently）非常重要，这是因为请求响应最慢的客户往往也是数据最多的客户

排队延迟（queueing delay）占了Tail latencies的很大一部分，只要有少量缓慢的请求就能阻碍后续请求的处理

应对负载需要将vertical scaling（换更好的机器）和horizontal scaling（将负载分布到多台小机器上）灵活地结合

### 无状态服务 (Stateless Service)
无状态服务指的是每个请求都是独立的，服务器不保留任何关于客户端的会话信息。每个请求都包含了服务器处理所需的所有信息。

例如：RESTful API

# 数据模型与查询语言
## NoSQL
NoSQL数据库是一类非关系型数据库，专门设计用于处理大量的数据和高并发的应用程序需求

特点：不使用固定的表格结构，而是采用灵活的数据模型，如键-值对、文档、列族、图等。

### NoSQL数据库的主要类型
1. 键-值存储（Key-Value Store）

    特点：通过键-值对来存储数据，适用于简单的数据存取。
    示例：Redis, Riak

2. 文档存储（Document Store）

    特点：数据以文档的形式存储，通常使用JSON、BSON等格式，每个文档可以有不同的结构。
    示例：MongoDB, CouchDB

3. 列族存储（Column Family Store）

    特点：数据以列簇的形式存储，适用于存储大量的半结构化数据。
    示例：Apache Cassandra, HBase

4. 图数据库（Graph Database）

    特点：使用节点、边和属性来存储数据，特别适合处理复杂的关系和连接。
    示例：Neo4j, ArangoDB

### 优缺点
优点：

* 扩展性强：NoSQL数据库通常支持水平扩展，即通过增加更多的服务器节点来处理更多的数据和请求。

* 高性能：针对特定的查询和存储模式进行了优化，可以提供高并发的读写性能。

* 灵活的数据模型：支持灵活的、动态的模式，无需预定义表结构，适用于快速变化的应用需求。

* 大数据处理：适合处理海量数据，能够存储和处理比关系型数据库更多的数据。

* 高可用性和容错性：许多NoSQL数据库内置了自动分片、复制和容错机制，能够在硬件故障时提供高可用性。

缺点：可能导致数据不一致、查询复杂、事务处理能力有限

# 存储与检索
## 索引
索引是一种数据结构，用于快速查询数据库表中的数据。基本思想是通过保存一些额外的元数据作为路标来快速找到想要的数据

### 常见索引类型
1. 哈希索引：通过哈希函数将键值映射到哈希表中的具体位置，比较适用于等值查询。优点是结构相对简单，通常占用更少的存储空间

2. B树索引

3. bitmap索引

4. 复合索引

## Bitcask

### 工作原理
Bitcask 将所有写操作（如插入、更新）记录到日志文件（write-ahead log）的末尾。这些日志文件按顺序写入磁盘，每个日志文件被称为一个data file。一个Bitcask实例是一个目录，一个目录里可能有多个data files，但只能有一个active data file（用于服务器写入数据），且同一时刻只能有一个进程操作该目录。当active file大小达到一个阈值时会被关闭，同时创建新的active data file。旧的data file是不可变和不可写的。

**Bitcask实例 = 一个active data file+多个旧的data file**

### 为何写入数据很快
Bitcask采用append-only的写入方式，这是因为机械硬盘（HDD）的顺序写入速度远快于随机写入，因为顺序写入只需磁盘旋转和磁头移动一次，而随机写入需要多次寻址，所以这么做能够避免多余的磁盘寻址。Bitcask只有一个writer thread，简化了并发控制

### 为何读取数据很快
Bitcask维护一个**保存于内存中**的哈希索引，这个哈希索引将键映射到对应的数据文件及其在文件中的偏移量。通过这个哈希索引，可以快速定位到存储在磁盘上的数据

Bitcask会定期在后台执行merge操作以清理无用数据，merge过程就是遍历所有的旧的data files，然后将所有有效（没有被删除）的键的最新版本写入到新的文件中，最后再将旧的data files删除。此外，还会进行压缩（compaction）操作，即在日志中丢弃重复的键，只保留每个键的最近更新。

Bitcask的删除是逻辑删除，即追加一次删除记录，在下一次merge时才真正物理删除

### 数据备份和恢复
Bitcask*定期将Keydir的快照保存到磁盘*，以便在系统崩溃后快速恢复，同时也会定期将数据文件复制到安全的位置，以确保数据的持久性

### 适用场景
适用于*高写入吞吐量*，需要*快速读取*，数据更新频率相对较低

### 局限性
由于keydir得存在内存中，因此适用的*数据规模有限*，*键不能太多*。*不支持范围查询*。单线程写入*不适合高并发场景*。由于每次更新都会生成新的数据版本，旧版本的数据需要等待合并和清理操作才能被删除，可能导致*磁盘空间利用率*不高。

## LSM树
*注意，LSM树不是一种树状数据结构，而是一种存储结构*

两个重要组成部分：

1. SSTable（Sorted String Table）：有序键值对集合。集合中的键是按顺序排列的。SSTable是LSM树组在磁盘中的数据结构。SSTable有两个优势：

* 合并段简单而高效：比较像归并排序，在合并时并排读取输入文件，查看每一个键并将最低的键输出到输出文件
* 无需保存内存中所有键的索引，每几千字节的段文件就有一个键就足够了，其他键可以从已知键的偏移位置处开始扫描

2. Memtable（内存表）。Memtable用于将数据按键排序成为SSTable，它是*位于内存中的某种平衡树数据结构（例如，红黑树或Skip List）*。当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。新的SSTable文件成为数据库的最新部分。读取数据时，先在内存表中找，若未找到则依次查找最近的磁盘段，直到找到该关键字为止。

### 如何解决内存表尚未写入磁盘数据库就崩溃的情况
可以在磁盘上保存一个单独的日志（称为WAL，即Write-Ahead Log），每个写入都会立即被附加到磁盘上。每当内存表写出到SSTable时，相应的日志都可以被丢弃。

### 补充内容
压缩（Compaction）：LSM树会定期进行压缩操作，将多个SSTable文件合并成一个新的SSTable文件，以减少磁盘空间占用并提升查询性能。

布隆过滤器（Bloom Filter）：为了加速查询，LSM树常使用布隆过滤器来快速判断某个键是否存在于SSTable中，减少不必要的磁盘读取。